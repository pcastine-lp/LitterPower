/*	File:		Taus88.h	Contains:	Header file for Taus88.	Written by:	Peter Castine	Copyright:	© 2001-2006 Peter Castine	Change History (most recent first):         <3>   24Ð3Ð2006    pc      Fix compile problems with the signal vector versions we hadn't                                    dealt with yet.         <2>   23Ð3Ð2006    pc      Expose "global" seed set. The data must only be used in                                    conjunction with the inline Taus88 calls.         <1>     26Ð2Ð06    pc      First checked in. Split off  Taus88 functions that had collected                                    in LitterLib.*//****************************************************************************************** ******************************************************************************************/#pragma once#ifndef __TAUS88_H__#define __TAUS88_H__#pragma mark ¥ Include Files#ifndef __MACTYPES__	#include <MacTypes.h>									// For UInt32#endif#ifndef __MAXUTILS_H__	#include "MaxUtils.h"#endif#ifndef __MISCUTILS_H__	#include "MiscUtils.h"#endif#pragma mark ¥ Constants#pragma mark ¥ Type Definitionstypedef struct taus88Data {					UInt32	seed1,							seed2,							seed3;					} tTaus88Data;typedef tTaus88Data* tTaus88DataPtr;#pragma mark ¥ Global Variablesextern tTaus88Data	gTausData;								// Default seed set#pragma mark ¥ Function Prototypes	// Tausworthe 88...UInt32			Taus88			(tTaus88DataPtr);void			Taus88Init		(void);void			Taus88Seed		(tTaus88DataPtr, UInt32);tTaus88DataPtr	Taus88New		(UInt32);					// Do not call New/Free atvoid			Taus88Free		(tTaus88DataPtr);			// interrupt level.#ifdef __MAX_MSP_OBJECT__	void		Taus88SigVector	(tSampleVector, UInt32);	void		Taus88SigVectorMasked(tSampleVector, UInt32, UInt32, UInt32);	float		Taus88TriSig	(void);#endif	// __MAX_MSP_OBJECT__	// These functions, which will be defined inline, abstract the	// Taus88() RNG. Call Taus88Load() the beginning of a function, call Taus88Process()	// as many times as needed to generate random deviates, then call Taus88Store to	// save register state. The only other thing a function using these needs to do is	// to declare three registers to use, and it must have access to a properly	// seeded tTaus88DataPtr.static inline tTaus88DataPtr Taus88GetGlobals(void)	{ return &gTausData; }static inline void Taus88Load(tTaus88Data* iData, UInt32* oReg1, UInt32* oReg2, UInt32* oReg3)	{ *oReg1 = iData->seed1; *oReg2 = iData->seed2; *oReg3 = iData->seed3; }static inline void Taus88LoadGlobal(UInt32* oReg1, UInt32* oReg2, UInt32* oReg3)	{ *oReg1 = gTausData.seed1; *oReg2 = gTausData.seed2; *oReg3 = gTausData.seed3; }static inline void Taus88Store(tTaus88Data* oData, UInt32 iReg1, UInt32 iReg2, UInt32 iReg3)	{ oData->seed1 = iReg1; oData->seed2 = iReg2; oData->seed3 = iReg3; }static inline void Taus88StoreGlobal(UInt32 iReg1, UInt32 iReg2, UInt32 iReg3)	{ gTausData.seed1 = iReg1; gTausData.seed2 = iReg2; gTausData.seed3 = iReg3; }static inline UInt32 Taus88Process(UInt32* ioReg1, UInt32* ioReg2, UInt32* ioReg3)	{	const UInt32	tausMagic1	= 0xfffffffe,					tausMagic2	= 0xfffffff8,					tausMagic3	= 0xfffffff0;	UInt32 x;		x  = ((*ioReg1 << 13) ^ *ioReg1) >> 19;	*ioReg1 = ((*ioReg1 & tausMagic1) << 12) ^ x;	x  = ((*ioReg2 << 2) ^ *ioReg2) >> 25;	*ioReg2 = ((*ioReg2 & tausMagic2) << 4) ^ x;		x  = ((*ioReg3 << 3) ^ *ioReg3) >> 11;	*ioReg3 = ((*ioReg3 & tausMagic3) << 17) ^ x;		return *ioReg1 ^ *ioReg2 ^ *ioReg3; 	}static inline double Taus88Unit(tTaus88DataPtr ioData)	{ return ULong2Unit_Zo( Taus88(ioData) ); }static inline float Taus88Signal(tTaus88DataPtr ioData)	{ return Long2Signal( Taus88(ioData) ); }	#endif		// ifndef __TAUS88_H__